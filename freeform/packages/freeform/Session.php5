<?

/**
 * This is a static class to interface session implementation used in given application.
 * See <class>SessionHandler</class> interface for description of methods.
 * All methods are shortcuts to corresponding methods of a concrete SessionHandler
 * implementation.
 *
 * @author Dennis Popel  
 * @since 1.0
 */
final class Session {
  private static $sessionImpl;
  
  /**
   * Called by the front controller to assign a handler for given application
   * based on Freefrom package configuration
   *
   * @param  SessionHandler $sessionHandler  session handler
   */
  static function setHandler(SessionHandler $sessionHandler) {
    self::$sessionImpl = $sessionHandler;
  }
  
  /**
   * Set a session variable. This variable will be accessible in following
   * requests.
   *
   * @param  string $name  name of the variable
   * @param  mixed $value  value
   */
  static function setVariable($name, $value) {
    self::$sessionImpl->setVariable($name, $value);
  }
  
  /**
   * Get a session variable
   *
   * @param   string $name  name of a session variable
   * @param   mixed $defValue  the default value to return if no such session variable
   * @return  session variable $name or null
   */
  static function getVariable($name, $defValue = null) {
    return is_null($rv = self::$sessionImpl->getVariable($name)) ? $defValue : $rv;
  }
  
  /**
   * Get current user
   *
   * @return  User  current user
   */
  static function getUser() {
    return self::$sessionImpl->getUser();
  }  
  
  /**
   * Set current user
   * NOTE: it should be declared setUser(User $user), but... You know PHP5.
   *
   * @param  User $user  current user or null to log off
   */
  static function setUser($user) {
    self::$sessionImpl->setUser($user);
  }
  
  /**
   * Return true if the session is expired. If a call to this returns true, it
   * means that current session is valid and can be further used, but all session
   * variables and user are lost. Effectively, this means that the previous session
   * has expired.
   *
   * @return  bool  true if the session expired
   */
  static function isExpired() {
    return self::$sessionImpl->isExpired();
  }
  
  /**
   * Set the private mode for the session. This means that pages generated by subsequent
   * requests will be tailored to meet certain user and his preferences. Setting a particular
   * private hash will be used to distinguish pages generated by the requests for same URLs
   * but intended for different users by both the client and the server-side cache.
   * If the responce will have lifetime set, the document will be cached by the server and
   * returned from cache for subsequent requests that happen not later than the cache 
   * expired.
   * @param  string $hash  a unique hash for the private mode or null
   */
  function setPrivateMode($hash) {
    self::$sessionImpl->setPrivateMode($hash);
  }
  
  /**
   * Return the private mode hash if any
   * @return  string  the private mode hash or null
   */
  function getPrivateMode() {
    return self::$sessionImpl->getPrivateMode();
  }
}

?>